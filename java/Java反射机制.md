#### Java反射总结
在之前的学习中，我们创建新对象的方式是通过new，这种方式会造成类之间的耦合，例如在简单的工厂模式中，用getInstance（"传入需要获得类的标识"），用我们之前学习的只是，当有新的类加入工厂时，我们不得不去修改工厂的方法，造成耦合问题；此时！！！一个新的获得类对象的方式帮助我们解决了这个问题，反射机制，反射机制中最重要的部分是Class类，Class通过传入的全限定类名（Class.forName（"全限定类名称"））去创建该类的Class对象，再通过newInstance调用该类的无参构造函数获得实例化对象；这时再去考虑之前的耦合问题，当有新的类加入工厂时，我们只用将全限定类名传入工厂中就可以获得该类的对象，耦合度减少很多，可以做到动态加载。  

每一个类都会在类加载的加载阶段去诞生一个Class类对象，这个类对象会一直跟随着类，通过Class类，可以获得对应类的Constructor,Method,Fileds并动态操作。  

反射在框架中被大范围使用，回想之前在各种配置文件中配置的class属性，要求我们传入类的全限定名称，这就是反射的使用：
struts2框架中，当有新的请求传来时，action 代理会根据请求去加载配置文件，找到对应的Action并执行相应的method，我们用该new一个Action的对象，然后对象.method去调用指定的方法，但是！！！这些我们都没有去做，当然如果我们这样去做的的话耦合度也太大了，每增加一个新的Action，我们都要深入代码中去修改调用机制，这里很机智的使用了反射机制，实现了动态加载，只通过配置累的全限定类名就可以帮我们处理对象的实例化；     这里再说一下javaBean为什么必须设置为set，get，是因为在通过反射调用method就行属性注入时候的代码写成了固定的的set，get形式
spring的bean
hibernate对SQL查询结果的封装，
